M001		A:\PJ\mamo\refs\isses\stocks\M001.txt

問題を読み解く
問題と答え
便利なリテラル表現

Pythonで実装
Rubyで実装
JavaScriptで実装
Groovyで実装
Javaで実装
Haskellで実装
OCamlで実装
C++で実装
Cで実装
Rustで実装


問題を読み解く
先頭と末尾がつながった数値のリストから、あるルールに則した選別を行い集積した結果から最大の値を得る事が問題の答えだ。
ルールは、選別に加えた、数値の次の数値は選別出来ない事だ。つまり先頭を選別すれば末尾が、末尾を選別すれば先頭が選別できない。
なので、添え字０から始めるループと１から始めるループが必要で、それぞれのループの中の選別ルールは変わらない。
確定した累積値と二つの候補値をキャシュする配列と、最大値が更新される度に自らを書き換える蓄積変数の二つで解決する。

問題と答え
isse1
10 3 2 5 7 8
res1
19

isse2
11 15
res2
15

isse3
7 7 7 7 7 7 7
res3
21

isse4
1 2 3 4 5 1 2 3 4 5
res4
16

isse5
94 40 49 65 21 21 106 80 92 81 679 4 61 6 237 12 72 74 29 95 265 35 47 1 61 397 52 72 37 51 1 81 45 435 7 36 57 86 81 72
res5
2926

isse6
84 28 43 39 50 74
res6
177

便利なリテラル表現
["10 3 2 5 7 8"]
[10,3,2,5,7,8]


Pythonで実装
Pythonのmaxは関数なので、引数のタイプによって挙動を変化させる事が出来る。

def m001(ss): return to_nums(ss[0])
def test_m(): ns = m001(["10 3 2 5 7 8"]); print(ns)

def domain(ns):
  N = len(ns); dp = []; ans = 0
  for i in range(0,N-1):　０から始めるループ
    dp.append(ns[i])
    if i > 0 : dp[i] = max(dp[i], dp[i-1])
    if i > 1 : dp[i] = max(dp[i], dp[i-2] + ns[i])
    ans = max(ans, dp[i])
  for i in range(0,N-1):　１から始めるループ
    dp[i] = ns[i+1]
    if i > 0: dp[i] = max(dp[i], dp[i-1])
    if i > 1: dp[i] = max(dp[i], dp[i-2] + ns[i+1])
    ans = max(ans, dp[i])
  return ans
def test(): res = domain([1,2,3,100,4]); print(res)

def domains(ss): #main
  res = domain(m001(ss))
  return [str(res)]
def test_ds(): ans = domains(["1 2 3 4 5 1 2 3 4 5"]); print(ans)


Rubyで実装
RubyでのmaxはEnumerableのmaxメソッドを使う。つまりいったん候補をリストに詰め直す必要がある。

def m001(ss) to_nums ss[0] end
def test_m() res = m001 ["10 3 2 5 7 8"]; p(res) end   #exp is exp

def domain(ns)
  n = ns.size; ans = 0; bp = [];
  for i in 0..n-2 do
    bp << ns[i]
    if i > 0 then bp[i] = [bp[i],bp[i-1]].max end
    if i > 1 then bp[i] = [bp[i], bp[i-2] + ns[i]].max end
    ans = [ans, bp[i]].max
  end
  for i in 0..n-2 do
    bp[i] = ns[i+1]
    if i > 0 then bp[i] = [bp[i],bp[i-1]].max end
    if i > 1 then bp[i] = [bp[i],bp[i-2] + ns[i+1]].max end
    ans = [ans,bp[i]].max
  end
  ans
end
def test_d() res = domain [10,3,2,5,7,8]; p res end   #exp is exp

def domains(ss) # main
  arg = m001(ss)
  res = domain(arg)
  [res.to_s]
end
def test()  res = domains ["1 2 3 4 5 1 2 3 4 5"]; p res end

JavaScriptで実装

function m001(ss){ return fs.to_nums(ss[0]);}
function test_m(){ let res = m001(["10 3 2 5 7 8"]); console.log(res);}

function domain(ns){
  let ans = 0, dp = [];
  for(let i= 0; i<ns.length-1; i++){
    dp.push(ns[i]);
    if( i > 0){ dp[i] = Math.max(dp[i], dp[i-1]);}
    if( i > 1){ dp[i] = Math.max(dp[i], dp[i-2] + ns[i]);}
    ans = Math.max(ans, dp[i]);
  }
  for(let i= 0; i<ns.length-1; i++){
    dp[i] = ns[i+1];
    if( i > 0){ dp[i] = Math.max(dp[i], dp[i-1]);}
    if( i > 1){ dp[i] = Math.max(dp[i], dp[i-2] + ns[i+1]);}
    ans = Math.max(ans, dp[i]);
  }
  return ans;
}
function test(){
  let res = domain([10,3,2,5,7,8]); console.log(res);
}  // exp is exp
// main
function domains(args){
  let res = domain(m001(args));
  return [res.toString()];
}
function test_ds(){ let ans = domains(["10 3 2 5 7 8"]); console.log(ans);}  // exp is 

Groovyで実装

def m001(ss){ return to_nums(ss[0]);}
def test_m(){ def res = m001(["10 3 2 5 7 8"]); println(res);}   // exp is

def domain(ns){
  def ans = 0, dp = [];
  for(int i= 0; i<ns.size()-1; i++){
    dp << ns[i]; 
    if( i > 0){ dp[i] = Math.max(dp[i], dp[i-1]);}
    if( i > 1){ dp[i] = Math.max(dp[i], dp[i-2] + ns[i]);}
    ans = Math.max(dp[i], ans);
  }
  for(int i= 0; i<ns.size()-1; i++){
    dp[i] = ns[i+1];
    if( i > 0){ dp[i] = Math.max(dp[i], dp[i-1]);}
    if( i > 1){ dp[i] = Math.max(dp[i], dp[i-2] + ns[i+1]);}
    ans = Math.max(dp[i], ans);
  }
  return ans;
}
def test_d(){ def res = domain([10,3,2,5,7,8]); println(res);}   // exp is

def domains(ss){ // main
  def res = domain(m001(ss));
  return [res.toString()];
}
def test(){ def res = domains(["10 3 2 5 7 8"]); println(res);}


Javaで実装

private void m001() { this.ns = fs.toNums(lines.get(0));}
  public void test_m(){ m001(); System.out.println(this.ns);} // exp is 

  private int domain(List<Integer> ns) {
    int ans = 0; List<Integer> dp = new ArrayList<>();
    for(int i= 0; i<ns.size() - 1; i++){
      dp.add(ns.get(i));
      if( i > 0){ dp.set(i, Math.max(dp.get(i), dp.get(i-1)));}
      if( i > 1){ dp.set(i, Math.max(dp.get(i), dp.get(i-2)+ ns.get(i)));}
      ans = Math.max(dp.get(i), ans);
    }
    for(int i= 0; i<ns.size() - 1; i++){
      dp.set(i, ns.get(i+1));
      if( i > 0){ dp.set(i, Math.max(dp.get(i), dp.get(i-1)));}
      if( i > 1){ dp.set(i, Math.max(dp.get(i), dp.get(i-2)+ ns.get(i+1)));}
      ans = Math.max(dp.get(i), ans);
    }
    return ans;
  }
  public void test_d(){
    List<Integer> arg = asList(10,3,2,5,7,8);
    int res = domain(arg); System.out.println(res);
  }  // exp is exp

  public List<String> domains(){
    m001(); int res = domain(this.ns);
    return asList(String.valueOf(res));
  }// main
  public void test(){ List<String> res = domains(); System.out.println(res);}


Haskellで実装
蓄積変数や繰り返しがふんだんに使われる手続き型のロジックを関数型に移植する作業はいつも骨が折れる。
今回は、二つのfoldlを使ってその中からの最大値を検出する事で何とか移植できた。けど、関数型らしい実装では無い気がする。
m001 :: [String] -> [Int]
m001 (s:_) =  to_nums s
test_m = let res = m001 ["10 3 2 5 7 8"] in show res  -- exp is

setter :: a -> Int -> [a] -> [a]
setter v i xs = f ++ (v:r) where f = take i xs; r = drop (i+1) xs
test_s = let res = setter 10 0 [0,0,0,0,0] in show res

domain :: (Num a, Ord a) => [a] -> [a] -> a
domain ns dp = max (maximum (foldl(folder1) dp [0..(length dp)-1])) (maximum (foldl(folder2) dp [0..(length dp)-1])) where
  folder1 ac i = let ac1 = setter (ns!!i) i ac in if i > 0 
    then let m = max (ac1!!i) (ac1!!(i-1)) in let ac2 = setter m i ac1 in if i > 1
      then let m2 = max (ac2!!i) (ac2!!(i-2) + ns!!i) in setter m2 i ac2
      else ac2
    else ac1
  folder2 ac i = let ac1 = setter (ns!!(i+1)) i  ac in if i > 0
    then let m = max (ac1!!i) (ac1!!(i-1)) in let ac2 = setter m i ac1 in if i > 1
      then let m2 = max (ac2!!i) (ac2!!(i-2) + ns!!(i+1)) in setter m2 i ac2
      else ac2
    else ac1
test = let res = domain [10,3,2,5,7,8] [0,0,0,0,0] in show res

domains :: [String] -> [String]
domains ss = let ns = m001 ss; dp = replicate (length ns - 1) 0 in [show $domain ns dp]
test_ds = let res = domains ["10 3 2 5 7 8"] in show res

OCamlで実装
基本的な戦略はHaskellで出来ているので、OCamlの流儀に合わせるだけだ。


C++で実装
Cで実装
Rustで実装
