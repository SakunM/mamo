M001		A:\PJ\mamo\refs\isses\stocks\M001.txt

問題を読み解く
問題と答え
便利なリテラル表現

Pythonで実装
Rubyで実装
JavaScriptで実装
Groovyで実装
Javaで実装
Haskellで実装
OCamlで実装
C++で実装
Cで実装
Rustで実装


問題を読み解く
先頭と末尾がつながった数値のリストから、あるルールに則した選別を行い集積した結果から最大の値を得る事が問題の答えだ。
ルールは、選別に加えた、数値の次の数値は選別出来ない事だ。
つまり末尾と先頭がつながったリストでは、先頭を選別すれば末尾が、末尾を選別すれば先頭が選別できないって事だ。
また、最大値が要求されているので、今までの集積した値より隣の値が大きければその値を初期値に前の値を捨てる事で
そこからルールに則して集積を始める事が出来る事が問題を少し複雑にしている。お手本コードは、要求である最大値を得る事に特化して、
本当に、ルールが順守されているのか、確かめる事がむずかしい・・
無駄な蓄積変数を省いたり、引数から実際に選別される値や添え字を表示する事が難しい


つまり、このロジックはかなり抽象化されている・・初めはもっと直感的でなければならないと思う、
時間がかかっても、納得のいく方法が必要だ。



問題と答え
isse1
10 3 2 5 7 8
res1
19

isse2
11 15
res2
15

isse3
7 7 7 7 7 7 7
res3
21

isse4
1 2 3 4 5 1 2 3 4 5
res4
16

isse5
94 40 49 65 21 21 106 80 92 81 679 4 61 6 237 12 72 74 29 95 265 35 47 1 61 397 52 72 37 51 1 81 45 435 7 36 57 86 81 72
res5
2926

isse6
84 28 43 39 50 74
res6
177

便利なリテラル表現
["10 3 2 5 7 8"]
[10,3,2,5,7,8]


Pythonで実装

def m001(ss): return to_nums(ss[0])  # 冠関数（ファイル名と同名の関数）では、
	# 単純に空白区切りの数値変換可能な文字列を数値のリストへ変換。
def test_m(): ns = m001(["10 3 2 5 7 8"]); print(ns)

def max2(a,b): return  a if a > b else b  # Pythonでは、maxはリストの最大値を返す。なので単純なmaxはmax2として自作
def domain(ns):
  N = len(ns); dp = []; ans = 0
  for i in range(0,N-1):
    dp.append(ns[i])
    if i > 0 : dp[i] = max2(dp[i], dp[i-1])
    if i > 1 : dp[i] = max2(dp[i], dp[i-2] + ns[i])
    ans = max2(ans, dp[i])
  for i in range(0,N-1):
    dp[i] = ns[i+1]
    if i > 0: dp[i] = max2(dp[i], dp[i-1])
    if i > 1: dp[i] = max2(dp[i], dp[i-2] + ns[i+1])
    ans = max2(ans, dp[i])
  return ans
def test_d(): res = domain([10,3,2,5,7,8]); print(res)

def domains(ss): #main
  res = domain(m001(ss))
  return [str(res)]
def test(): ans = domains(["1 2 3 4 5 1 2 3 4 5"]); print(ans)


Rubyで実装
JavaScriptで実装
Groovyで実装
Javaで実装
Haskellで実装
OCamlで実装
C++で実装
Cで実装
Rustで実装
